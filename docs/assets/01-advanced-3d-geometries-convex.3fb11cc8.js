import{V as x,aq as $,ar as tt,as as et,m as z,K as k,G as nt,n as st,at as it,au as ot,f as H,s as at,S as rt,C as lt,P as ct,W as ht,A as ut,a as dt,b as pt}from"./stats.module.1062c650.js";import{O as ft}from"./OrbitControls.3104130d.js";import{c as mt}from"./SceneUtils.7c052e71.js";import{d as At,g as W,h as gt,c as wt,f as b,o as xt}from"./index.6c251f58.js";const V=0,vt=1,Ct=new x,y=new $,T=new tt,B=new x,P=new et;class I{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new D,this.unassigned=new D,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new Ft(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(s){const i=s.geometry;if(i!==void 0){const n=i.attributes.position;if(n!==void 0)for(let l=0,o=n.count;l<o;l++){const c=new x;c.fromBufferAttribute(n,l).applyMatrix4(s.matrixWorld),e.push(c)}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++)if(e[s].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,n=1/0;for(let l=0,o=s.length;l<o;l++){const c=s[l],r=c.distanceToPoint(t.origin),p=c.normal.dot(t.direction);if(r>0&&p>=0)return null;const u=p!==0?-r/p:0;if(!(u<=0)&&(p>0?n=Math.min(u,n):i=Math.max(u,i),i>n))return null}return i!==-1/0?t.at(i,e):t.at(n,e),e}intersectsRay(t){return this.intersectRay(t,Ct)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let s=t.outside;for(;s.next!==null&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(s!==void 0)if(e===void 0)this.unassigned.appendChain(s);else{let i=s;do{const n=i.next;e.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,e):this.unassigned.append(i),i=n}while(i!==null)}return this}resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,n=null;for(let l=0;l<t.length;l++){const o=t[l];if(o.mark===V){const c=o.distanceToPoint(e.point);if(c>i&&(i=c,n=o),i>1e3*this.tolerance)break}}n!==null&&this.addVertexToFace(e,n),e=s}while(e!==null)}return this}computeExtremes(){const t=new x,e=new x,s=[],i=[];for(let n=0;n<3;n++)s[n]=i[n]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let n=0,l=this.vertices.length;n<l;n++){const o=this.vertices[n],c=o.point;for(let r=0;r<3;r++)c.getComponent(r)<t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),s[r]=o);for(let r=0;r<3;r++)c.getComponent(r)>e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),i[r]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let n=0,l=0;for(let a=0;a<3;a++){const f=i[a].point.getComponent(a)-s[a].point.getComponent(a);f>n&&(n=f,l=a)}const o=s[l],c=i[l];let r,p;n=0,y.set(o.point,c.point);for(let a=0,f=this.vertices.length;a<f;a++){const h=t[a];if(h!==o&&h!==c){y.closestPointToPoint(h.point,!0,B);const m=B.distanceToSquared(h.point);m>n&&(n=m,r=h)}}n=-1,T.setFromCoplanarPoints(o.point,c.point,r.point);for(let a=0,f=this.vertices.length;a<f;a++){const h=t[a];if(h!==o&&h!==c&&h!==r){const m=Math.abs(T.distanceToPoint(h.point));m>n&&(n=m,p=h)}}const u=[];if(T.distanceToPoint(p.point)<0){u.push(g.create(o,c,r),g.create(p,c,o),g.create(p,r,c),g.create(p,o,r));for(let a=0;a<3;a++){const f=(a+1)%3;u[a+1].getEdge(2).setTwin(u[0].getEdge(f)),u[a+1].getEdge(1).setTwin(u[f+1].getEdge(0))}}else{u.push(g.create(o,r,c),g.create(p,o,c),g.create(p,c,r),g.create(p,r,o));for(let a=0;a<3;a++){const f=(a+1)%3;u[a+1].getEdge(2).setTwin(u[0].getEdge((3-a)%3)),u[a+1].getEdge(0).setTwin(u[f+1].getEdge(1))}}for(let a=0;a<4;a++)this.faces.push(u[a]);for(let a=0,f=t.length;a<f;a++){const h=t[a];if(h!==o&&h!==c&&h!==r&&h!==p){n=this.tolerance;let m=null;for(let w=0;w<4;w++){const v=this.faces[w].distanceToPoint(h.point);v>n&&(n=v,m=this.faces[w])}m!==null&&this.addVertexToFace(h,m)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.mark===V&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const n=s.distanceToPoint(i.point);n>e&&(e=n,t=i),i=i.next}while(i!==null&&i.face===s);return t}}computeHorizon(t,e,s,i){this.deleteFaceVertices(s),s.mark=vt;let n;e===null?n=e=s.getEdge(0):n=e.next;do{const l=n.twin,o=l.face;o.mark===V&&(o.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,l,o,i):i.push(n)),n=n.next}while(n!==e);return this}addAdjoiningFace(t,e){const s=g.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let n=0;n<e.length;n++){const l=e[n],o=this.addAdjoiningFace(t,l);s===null?s=o:o.next.setTwin(i),this.newFaces.push(o.face),i=o}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();(t=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class g{constructor(){this.normal=new x,this.midpoint=new x,this.area=0,this.constant=0,this.outside=null,this.mark=V,this.edge=null}static create(t,e,s){const i=new g,n=new M(t,i),l=new M(e,i),o=new M(s,i);return n.next=o.prev=l,l.next=n.prev=o,o.next=l.prev=n,i.edge=n,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return P.set(t.point,e.point,s.point),P.getNormal(this.normal),P.getMidpoint(this.midpoint),this.area=P.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class M{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class Ft{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class D{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}class Et extends z{constructor(t=[]){super();const e=[],s=[];I===void 0&&console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");const n=new I().setFromPoints(t).faces;for(let l=0;l<n.length;l++){const o=n[l];let c=o.edge;do{const r=c.head().point;e.push(r.x,r.y,r.z),s.push(o.normal.x,o.normal.y,o.normal.z),c=c.next}while(c!==o.edge)}this.setAttribute("position",new k(e,3)),this.setAttribute("normal",new k(s,3))}}const Pt="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sHDgwCEMBJZu0AAAAdaVRYdENvbW1lbnQAAAAAAENyZWF0ZWQgd2l0aCBHSU1QZC5lBwAABM5JREFUWMO1V0tPG2cUPZ4Hxh6DazIOrjFNqJs0FIMqWFgWQkatsmvVbtggKlSVRVf5AWz4AWz4AUSKEChll19QJYSXkECuhFxsHjEhxCYm+DWGMZ5HF72DJq4bAzFXurI0M/I5997v3u9cC65vTJVn2lX/xHINQOYSBLTLEuIuCWw4Z3IGAEvf6ASmVHjNzHCXBG4A0AjACsAOwEbO0nsFQBnAGYASAIl+ZRMR7SolMEdsByD09fV5R0ZGgg8ePPjW5/N1iqLYpuu6RZblciKR2I9Go69evnwZnZ+fjwI4IS8AKBIRzeQfJWCANwKwh0KhtrGxsYehUOin1tbW+zzP23ietzY2NnIAoGmaLsuyUiqVyvl8XtrY2NiamZn589mzZxsAUgCOAeQAnFI2tI+VxIjaAeDzoaGh7xYWFuZOTk6OZVk+12uYqqq6JEnn0Wg0OT4+/geAXwGEAdwDIFJQXC1wO4DWR48e/RCPxxclSSroVzRFUbSDg4P848ePFwH8DuAhkWih83TRQWxFOXgAwvDwcOfo6OhvXV1d39tsNtuVBwTDWBwOh1UUxVsMw1hXVlbSdCgNV43uYSvrHg6H24aHh38eHBz85TrgF9FYLHA4HLzH43FvbW2d7u/vG+dANp8FpqIlbd3d3V8Fg8EfBUFw4BONZVmL3+9vHhkZCQL4AoAHgJPK8G+yzC0XDofdoVAo5PP5vkadTBAEtr+/39ff3x8gAp/RPOEqx2qjx+NpvXv3bk9DQ0NDvQgwDIOWlhZrMBj8kgi0UJdxRgYMArzL5XJ7vd57qLPZ7Xamp6fnNgBXtQxcjFuHw+Hyer3t9SYgCAITCAScAJoBNNEY/08GOFVVrfVMv7kMNDntFD1vjIAPrlRN0xjckOm6biFQ3jwNPwDMZrOnqVTqfb3Bi8Wivru7W/VCYkwPlKOjo0IikXh7EwQikYgE4Nw0CfXKDCipVCoTj8df3QABbW1tLUc6oUgkFPMkVACUNjc337148eKvw8PDbJ2jP1taWkoCyNDVXDSECmNSK4qiKNLq6urW8+fPI/UicHx8rD59+jSVy+WOAKSJhKENwFItLtoxk8mwsixzHR0dHe3t7c5PAU+n09rs7OzJkydPYqVSaQfANoDXALIk31S2smU1TWMPDg7K5XKZ7+3t9TudTut1U7+wsFCcmJiIpdPpbQBxADsAknQWymYCOukBHYCuKApisdhpMpnURFEU79y503TVyKenpzOTk5M7e3t7MQKPV0Zv1gNm+awB0MvlshqLxfLb29uyJElWURSbXC4XXyvqxcXFs6mpqeTc3Nzu3t7e3wQcA7BPZ8Cov1pNlJplmQtAG8MwHV6v95tAINA5MDBwPxAIuLu6upr8fr/VAN3c3JQjkcjZ+vp6fnl5+d2bN29SuVzuNYAEpf01CdRChUL+X1VskHACuA3Ay3Fcu9vt7nA6nZ7m5uYWQRCaNE3jVVW15PP580KhIGUymWw2m00DOAJwSP4WwPtq4LX2Ao6USxNlQyS/RcQcdLGwlNIz6vEMAaZpNzCk2Pll94LK/cDYimxERiBwG10sxjgvEZBE0UpE6vxj+0Ct5bTaXthgEhRmja8QWNkkPGsuIpfdjpkK+cZUWTC0KredVmtD/gdlSl6EG4AMvQAAAABJRU5ErkJggg==",Vt={class:"viewCon"},kt=At({__name:"01-advanced-3d-geometries-convex",setup(F){const{random:t,PI:e,floor:s,ceil:i,min:n,max:l,sin:o,cos:c}=Math,r=W(),p=W();let u=window.innerWidth,a=window.innerHeight,f,h,m,w,v,E;gt(()=>{Z(),L(),j(),N()});const U={pointNum:50};function j(){var A;let d=new nt({autoPlace:!1,width:300});d.domElement.style.cssText="position: fixed; top: 0; right: 0;",(A=p.value)==null||A.appendChild(d.domElement)}let R=0;function O(){E.rotation.y=R+=.01}function G(d,A){let C=new x;return C.x=t()*(A-d)+d,C.y=t()*(A-d)+d,C.z=t()*(A-d)+d,C}function L(){E=new st,m.add(E);let d=[];for(let S=0;S<U.pointNum;S++)d.push(G(-15,15));const A=new it({color:14037041,size:1,map:Q()(),alphaTest:.5}),C=new z().setFromPoints(d),q=new ot(C,A);E.add(q);const K=new Et(d),Y=new H({color:623843,transparent:!0,opacity:.5}),J=new H({wireframe:!0}),_=mt(K,[Y,J]);E.add(_)}function Q(){let d;const A=new at;return function(){return d||(d=A.load(Pt),d)}}function Z(){m=new rt,m.background=new lt(16777215),w=new ct(75,u/a,1,1e3),v=new ht({canvas:r.value,antialias:!0}),v.setSize(u,a),window.addEventListener("resize",X),m.add(new ut(1e3)),m.add(new dt(16777215)),f=pt(),p.value.append(f.dom),h=new ft(w,v.domElement),h.target=new x(0,0,0),h.object.position.set(0,30,50),h.update()}function N(){requestAnimationFrame(N),f.update(),O(),v.render(m,w)}function X(){u=window.innerWidth,a=window.innerHeight,w.aspect=u/a,w.updateProjectionMatrix(),v.setSize(u,a)}return(d,A)=>(xt(),wt("div",Vt,[b("div",{class:"canvasCon",ref_key:"canvasCon",ref:p},[b("canvas",{class:"canvas",ref_key:"canvasDom",ref:r},null,512)],512)]))}});export{kt as default};
